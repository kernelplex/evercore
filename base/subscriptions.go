package evercore

import (
    "context"
    "errors"
    "fmt"
    "log/slog"
    "os"
    "time"
)

// SubscriptionFilter controls which events are read by a subscription.
type SubscriptionFilter struct {
    AggregateType string   // optional; empty means all aggregates
    EventTypes    []string // optional; empty means all event types
    AggregateKey  *string  // optional
}

// StartFromKind identifies how a subscription initializes its cursor.
const (
    StartBeginning = "beginning"
    StartEnd       = "end"
    StartEventID   = "event_id"
    StartTimestamp = "timestamp"
)

// StartFrom specifies where to start a subscription from.
type StartFrom struct {
    Kind      string
    EventID   int64
    Timestamp time.Time
}

// Options controls runtime behavior of a subscription runner.
type Options struct {
    BatchSize    int
    PollInterval time.Duration
    Lease        time.Duration
    Owner        string // optional; autogenerated if empty
}

// ErrSubscriptionAlreadyOwned indicates the subscription could not be claimed
// because another owner currently holds the lease.
var ErrSubscriptionAlreadyOwned = errors.New("subscription already owned")

// RunSubscription ensures a durable subscription exists, claims a lease, and
// processes events using handler with at-least-once semantics.
func (store *EventStore) RunSubscription(
    ctx context.Context,
    name string,
    filter SubscriptionFilter,
    start StartFrom,
    opts Options,
    handler func(context.Context, []SerializedEvent) error,
) error {

    if opts.BatchSize <= 0 {
        opts.BatchSize = 100
    }
    if opts.PollInterval <= 0 {
        opts.PollInterval = 500 * time.Millisecond
    }
    if opts.Lease <= 0 {
        opts.Lease = 15 * time.Second
    }
    if opts.Owner == "" {
        host, _ := os.Hostname()
        opts.Owner = fmt.Sprintf("%s-%d", host, os.Getpid())
    }

    // Resolve type IDs (nullable)
    var aggTypeIdPtr *int64
    if filter.AggregateType != "" {
        id, err := store.getAggregateTypeId(nil, ctx, filter.AggregateType)
        if err != nil {
            return fmt.Errorf("resolve aggregate type: %w", err)
        }
        aggTypeIdPtr = &id
    }

    var eventTypeIdPtr *int64
    // For single event-type we set eventTypeId; multiple will be handled via join table
    var eventTypeIds []int64
    if len(filter.EventTypes) == 1 {
        id, err := store.getEventTypeId(nil, ctx, filter.EventTypes[0])
        if err != nil {
            return fmt.Errorf("resolve event type: %w", err)
        }
        eventTypeIdPtr = &id
    } else if len(filter.EventTypes) > 1 {
        eventTypeIds = make([]int64, 0, len(filter.EventTypes))
        for _, et := range filter.EventTypes {
            id, err := store.getEventTypeId(nil, ctx, et)
            if err != nil {
                return fmt.Errorf("resolve event type '%s': %w", et, err)
            }
            eventTypeIds = append(eventTypeIds, id)
        }
    }

    // Upsert subscription definition
    subID, err := store.storageEngine.UpsertSubscription(nil, ctx, name, aggTypeIdPtr, eventTypeIdPtr, filter.AggregateKey, start.Kind, start.EventID, &start.Timestamp)
    if err != nil {
        return fmt.Errorf("upsert subscription: %w", err)
    }

    // Add multi event types if specified
    for _, etID := range eventTypeIds {
        if err := store.storageEngine.AddSubscriptionEventType(nil, ctx, subID, etID); err != nil {
            return fmt.Errorf("add subscription event type: %w", err)
        }
    }

    // Attempt to claim the subscription
    claimed, err := store.storageEngine.ClaimSubscription(nil, ctx, name, opts.Owner, opts.Lease)
    if err != nil {
        return fmt.Errorf("claim subscription: %w", err)
    }
    if !claimed {
        return fmt.Errorf("%w: %s", ErrSubscriptionAlreadyOwned, name)
    }
    defer func() { _ = store.storageEngine.ReleaseSubscription(nil, context.Background(), name, opts.Owner) }()

    // Load it back to check cursor and init if needed
    sub, err := store.storageEngine.GetSubscriptionByName(nil, ctx, name)
    if err != nil {
        return fmt.Errorf("load subscription: %w", err)
    }

    // Initialize cursor if required
    if sub.LastEventID == 0 {
        switch sub.StartFrom {
        case StartEnd:
            maxID, err := store.storageEngine.GetMaxEventId(nil, ctx)
            if err != nil {
                return fmt.Errorf("init cursor (end): %w", err)
            }
            if maxID > 0 {
                if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, maxID); err != nil {
                    return fmt.Errorf("advance cursor (end): %w", err)
                }
                sub.LastEventID = maxID
            }
        case StartEventID:
            if sub.StartEventID > 0 {
                if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, sub.StartEventID); err != nil {
                    return fmt.Errorf("advance cursor (event_id): %w", err)
                }
                sub.LastEventID = sub.StartEventID
            }
        case StartTimestamp:
            if sub.StartTimestamp != nil && !sub.StartTimestamp.IsZero() {
                firstID, err := store.storageEngine.GetFirstEventIdFromTimestamp(nil, ctx, *sub.StartTimestamp)
                if err != nil {
                    return fmt.Errorf("init cursor (timestamp): %w", err)
                }
                // We want to read events with id >= firstID, so cursor is firstID-1
                if firstID > 0 {
                    if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, firstID-1); err != nil {
                        return fmt.Errorf("advance cursor (timestamp): %w", err)
                    }
                    sub.LastEventID = firstID - 1
                }
            }
        case StartBeginning:
            // nothing; default last_event_id = 0
        default:
            return fmt.Errorf("unknown start_from: %s", sub.StartFrom)
        }
    }

    // Main processing loop
    ticker := time.NewTicker(opts.PollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        // refresh latest subscription state
        sub, err = store.storageEngine.GetSubscriptionByName(nil, ctx, name)
        if err != nil {
            return fmt.Errorf("reload subscription: %w", err)
        }
        if !sub.Active {
            return fmt.Errorf("subscription '%s' is inactive", name)
        }

        events, err := store.storageEngine.GetEventsForSubscription(nil, ctx, sub, opts.BatchSize)
        if err != nil {
            return fmt.Errorf("get events: %w", err)
        }

        if len(events) == 0 {
            // idle; renew lease and wait
            if _, err := store.storageEngine.RenewSubscription(nil, ctx, name, opts.Owner, opts.Lease); err != nil {
                return fmt.Errorf("renew lease: %w", err)
            }
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-ticker.C:
                continue
            }
        }

        slog.Info("subscription batch", "name", name, "events", len(events), "from_event_id", events[0].EventID, "to_event_id", events[len(events)-1].EventID)

        // process batch
        if err := handler(ctx, events); err != nil {
            return fmt.Errorf("handler error: %w", err)
        }

        lastID := events[len(events)-1].EventID
        // Ensure we advance the cursor even if the caller canceled ctx during handler.
        // Use a short, bounded background context to persist the cursor update and lease.
        persistCtx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if lastID > sub.LastEventID {
            if err := store.storageEngine.AdvanceSubscriptionCursor(nil, persistCtx, sub.ID, lastID); err != nil {
                return fmt.Errorf("advance cursor: %w", err)
            }
        }

        // renew lease proactively (best-effort)
        if _, err := store.storageEngine.RenewSubscription(nil, persistCtx, name, opts.Owner, opts.Lease); err != nil {
            return fmt.Errorf("renew lease: %w", err)
        }
    }
}

// RunEphemeralSubscription streams events without creating any persisted subscription
// metadata or cursor. The position is tracked in-process only and is lost when
// the caller exits. Useful for local caches, projections that can rebuild, etc.
//
// Supports:
// - AggregateType (optional)
// - AggregateKey (optional)
// - EventTypes: if multiple are provided, filtering is applied in-memory.
//   For a single event type, filtering happens in the storage engine query.
func (store *EventStore) RunEphemeralSubscription(
    ctx context.Context,
    filter SubscriptionFilter,
    start StartFrom,
    opts Options,
    handler func(context.Context, []SerializedEvent) error,
) error {
    if opts.BatchSize <= 0 { opts.BatchSize = 100 }
    if opts.PollInterval <= 0 { opts.PollInterval = 500 * time.Millisecond }

    // Resolve type IDs (nullable)
    var aggTypeIdPtr *int64
    if filter.AggregateType != "" {
        id, err := store.getAggregateTypeId(nil, ctx, filter.AggregateType)
        if err != nil { return fmt.Errorf("resolve aggregate type: %w", err) }
        aggTypeIdPtr = &id
    }

    var eventTypeIdPtr *int64
    var multiTypeFilter map[string]bool
    if len(filter.EventTypes) == 1 {
        id, err := store.getEventTypeId(nil, ctx, filter.EventTypes[0])
        if err != nil { return fmt.Errorf("resolve event type: %w", err) }
        eventTypeIdPtr = &id
    } else if len(filter.EventTypes) > 1 {
        multiTypeFilter = make(map[string]bool, len(filter.EventTypes))
        for _, et := range filter.EventTypes { multiTypeFilter[et] = true }
    }

    // Initialize cursor position (local only)
    var lastID int64
    switch start.Kind {
    case StartEnd:
        maxID, err := store.storageEngine.GetMaxEventId(nil, ctx)
        if err != nil { return fmt.Errorf("init cursor (end): %w", err) }
        lastID = maxID
    case StartEventID:
        if start.EventID > 0 { lastID = start.EventID }
    case StartTimestamp:
        if !start.Timestamp.IsZero() {
            firstID, err := store.storageEngine.GetFirstEventIdFromTimestamp(nil, ctx, start.Timestamp)
            if err != nil { return fmt.Errorf("init cursor (timestamp): %w", err) }
            if firstID > 0 { lastID = firstID - 1 }
        }
    case StartBeginning, "":
        lastID = 0
    default:
        return fmt.Errorf("unknown start_from: %s", start.Kind)
    }

    ticker := time.NewTicker(opts.PollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        // Build ephemeral subscription snapshot (ID=0, in-memory cursor)
        ep := &Subscription{ ID: 0, AggregateTypeID: aggTypeIdPtr, EventTypeID: eventTypeIdPtr, AggregateKey: filter.AggregateKey, LastEventID: lastID, Active: true }
        events, err := store.storageEngine.GetEventsForSubscription(nil, ctx, ep, opts.BatchSize)
        if err != nil { return fmt.Errorf("get events: %w", err) }

        if len(events) == 0 {
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-ticker.C:
                continue
            }
        }

        // Advance local cursor to the end of this batch
        lastID = events[len(events)-1].EventID

        // Apply in-memory filtering for multi-type if requested
        deliver := events
        if multiTypeFilter != nil {
            tmp := make([]SerializedEvent, 0, len(events))
            for _, e := range events {
                if multiTypeFilter[e.EventType] { tmp = append(tmp, e) }
            }
            deliver = tmp
        }

        if len(deliver) == 0 {
            // Nothing relevant; loop again
            continue
        }

        if err := handler(ctx, deliver); err != nil {
            return fmt.Errorf("handler error: %w", err)
        }
    }
}

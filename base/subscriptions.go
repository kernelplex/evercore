package evercore

import (
    "context"
    "fmt"
    "os"
    "time"
)

// SubscriptionFilter controls which events are read by a subscription.
type SubscriptionFilter struct {
    AggregateType string   // optional; empty means all aggregates
    EventTypes    []string // optional; empty means all event types
    AggregateKey  *string  // optional
}

// StartFromKind identifies how a subscription initializes its cursor.
const (
    StartBeginning = "beginning"
    StartEnd       = "end"
    StartEventID   = "event_id"
    StartTimestamp = "timestamp"
)

// StartFrom specifies where to start a subscription from.
type StartFrom struct {
    Kind      string
    EventID   int64
    Timestamp time.Time
}

// Options controls runtime behavior of a subscription runner.
type Options struct {
    BatchSize    int
    PollInterval time.Duration
    Lease        time.Duration
    Owner        string // optional; autogenerated if empty
}

// RunSubscription ensures a durable subscription exists, claims a lease, and
// processes events using handler with at-least-once semantics.
func (store *EventStore) RunSubscription(
    ctx context.Context,
    name string,
    filter SubscriptionFilter,
    start StartFrom,
    opts Options,
    handler func(context.Context, []SerializedEvent) error,
) error {

    if opts.BatchSize <= 0 {
        opts.BatchSize = 100
    }
    if opts.PollInterval <= 0 {
        opts.PollInterval = 500 * time.Millisecond
    }
    if opts.Lease <= 0 {
        opts.Lease = 15 * time.Second
    }
    if opts.Owner == "" {
        host, _ := os.Hostname()
        opts.Owner = fmt.Sprintf("%s-%d", host, os.Getpid())
    }

    // Resolve type IDs (nullable)
    var aggTypeIdPtr *int64
    if filter.AggregateType != "" {
        id, err := store.getAggregateTypeId(nil, ctx, filter.AggregateType)
        if err != nil {
            return fmt.Errorf("resolve aggregate type: %w", err)
        }
        aggTypeIdPtr = &id
    }

    var eventTypeIdPtr *int64
    // For single event-type we set eventTypeId; multiple will be handled via join table
    var eventTypeIds []int64
    if len(filter.EventTypes) == 1 {
        id, err := store.getEventTypeId(nil, ctx, filter.EventTypes[0])
        if err != nil {
            return fmt.Errorf("resolve event type: %w", err)
        }
        eventTypeIdPtr = &id
    } else if len(filter.EventTypes) > 1 {
        eventTypeIds = make([]int64, 0, len(filter.EventTypes))
        for _, et := range filter.EventTypes {
            id, err := store.getEventTypeId(nil, ctx, et)
            if err != nil {
                return fmt.Errorf("resolve event type '%s': %w", et, err)
            }
            eventTypeIds = append(eventTypeIds, id)
        }
    }

    // Upsert subscription definition
    subID, err := store.storageEngine.UpsertSubscription(nil, ctx, name, aggTypeIdPtr, eventTypeIdPtr, filter.AggregateKey, start.Kind, start.EventID, &start.Timestamp)
    if err != nil {
        return fmt.Errorf("upsert subscription: %w", err)
    }

    // Add multi event types if specified
    for _, etID := range eventTypeIds {
        if err := store.storageEngine.AddSubscriptionEventType(nil, ctx, subID, etID); err != nil {
            return fmt.Errorf("add subscription event type: %w", err)
        }
    }

    // Attempt to claim the subscription
    claimed, err := store.storageEngine.ClaimSubscription(nil, ctx, name, opts.Owner, opts.Lease)
    if err != nil {
        return fmt.Errorf("claim subscription: %w", err)
    }
    if !claimed {
        return fmt.Errorf("subscription '%s' is already owned", name)
    }
    defer func() { _ = store.storageEngine.ReleaseSubscription(nil, context.Background(), name, opts.Owner) }()

    // Load it back to check cursor and init if needed
    sub, err := store.storageEngine.GetSubscriptionByName(nil, ctx, name)
    if err != nil {
        return fmt.Errorf("load subscription: %w", err)
    }

    // Initialize cursor if required
    if sub.LastEventID == 0 {
        switch sub.StartFrom {
        case StartEnd:
            maxID, err := store.storageEngine.GetMaxEventId(nil, ctx)
            if err != nil {
                return fmt.Errorf("init cursor (end): %w", err)
            }
            if maxID > 0 {
                if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, maxID); err != nil {
                    return fmt.Errorf("advance cursor (end): %w", err)
                }
                sub.LastEventID = maxID
            }
        case StartEventID:
            if sub.StartEventID > 0 {
                if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, sub.StartEventID); err != nil {
                    return fmt.Errorf("advance cursor (event_id): %w", err)
                }
                sub.LastEventID = sub.StartEventID
            }
        case StartTimestamp:
            if sub.StartTimestamp != nil && !sub.StartTimestamp.IsZero() {
                firstID, err := store.storageEngine.GetFirstEventIdFromTimestamp(nil, ctx, *sub.StartTimestamp)
                if err != nil {
                    return fmt.Errorf("init cursor (timestamp): %w", err)
                }
                // We want to read events with id >= firstID, so cursor is firstID-1
                if firstID > 0 {
                    if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, firstID-1); err != nil {
                        return fmt.Errorf("advance cursor (timestamp): %w", err)
                    }
                    sub.LastEventID = firstID - 1
                }
            }
        case StartBeginning:
            // nothing; default last_event_id = 0
        default:
            return fmt.Errorf("unknown start_from: %s", sub.StartFrom)
        }
    }

    // Main processing loop
    ticker := time.NewTicker(opts.PollInterval)
    defer ticker.Stop()

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()
        default:
        }

        // refresh latest subscription state
        sub, err = store.storageEngine.GetSubscriptionByName(nil, ctx, name)
        if err != nil {
            return fmt.Errorf("reload subscription: %w", err)
        }
        if !sub.Active {
            return fmt.Errorf("subscription '%s' is inactive", name)
        }

        events, err := store.storageEngine.GetEventsForSubscription(nil, ctx, sub, opts.BatchSize)
        if err != nil {
            return fmt.Errorf("get events: %w", err)
        }

        if len(events) == 0 {
            // idle; renew lease and wait
            if _, err := store.storageEngine.RenewSubscription(nil, ctx, name, opts.Owner, opts.Lease); err != nil {
                return fmt.Errorf("renew lease: %w", err)
            }
            select {
            case <-ctx.Done():
                return ctx.Err()
            case <-ticker.C:
                continue
            }
        }

        // process batch
        if err := handler(ctx, events); err != nil {
            return fmt.Errorf("handler error: %w", err)
        }

        lastID := events[len(events)-1].EventID
        if lastID > sub.LastEventID {
            if err := store.storageEngine.AdvanceSubscriptionCursor(nil, ctx, sub.ID, lastID); err != nil {
                return fmt.Errorf("advance cursor: %w", err)
            }
        }

        // renew lease proactively
        if _, err := store.storageEngine.RenewSubscription(nil, ctx, name, opts.Owner, opts.Lease); err != nil {
            return fmt.Errorf("renew lease: %w", err)
        }
    }
}


// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package evercoresqlite

import (
	"context"
	"database/sql"
	"time"
)

const addAggregate = `-- name: AddAggregate :one

INSERT INTO aggregates (aggregate_type_id) VALUES (?1) 
	RETURNING id
`

// Aggregate Queries
func (q *Queries) AddAggregate(ctx context.Context, aggregateTypeID int64) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregate, aggregateTypeID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addAggregateType = `-- name: AddAggregateType :one

INSERT INTO aggregate_types (name) VALUES (?1) 
	RETURNING id
`

// Aggregate Type Queries
func (q *Queries) AddAggregateType(ctx context.Context, aggregateTypeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregateType, aggregateTypeName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addAggregateWithNaturalKey = `-- name: AddAggregateWithNaturalKey :one
INSERT INTO aggregates (aggregate_type_id, natural_key) VALUES(?1, ?2) 
	RETURNING id
`

type AddAggregateWithNaturalKeyParams struct {
	AggregateTypeID int64
	NaturalKey      sql.NullString
}

func (q *Queries) AddAggregateWithNaturalKey(ctx context.Context, arg AddAggregateWithNaturalKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, addAggregateWithNaturalKey, arg.AggregateTypeID, arg.NaturalKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addEvent = `-- name: AddEvent :exec

INSERT INTO events (aggregate_id, sequence, event_type_id, state, event_time, reference)
	VALUES(
		?1, 
		?2,
		?3, 
		?4,
		?5,
		?6
	)
`

type AddEventParams struct {
	AggregateID int64
	Sequence    int64
	EventTypeID int64
	State       string
	EventTime   time.Time
	Reference   string
}

// Event Queries
func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) error {
	_, err := q.db.ExecContext(ctx, addEvent,
		arg.AggregateID,
		arg.Sequence,
		arg.EventTypeID,
		arg.State,
		arg.EventTime,
		arg.Reference,
	)
	return err
}

const addEventType = `-- name: AddEventType :one

INSERT INTO event_types (name) VALUES(?1)
	RETURNING id
`

// Event Type Queries
func (q *Queries) AddEventType(ctx context.Context, eventName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, addEventType, eventName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const addSnapshot = `-- name: AddSnapshot :exec
INSERT INTO snapshots (aggregate_id, sequence, state) VALUES(?1, ?2, ?3)
`

type AddSnapshotParams struct {
	AggregateID int64
	Sequence    int64
	State       string
}

func (q *Queries) AddSnapshot(ctx context.Context, arg AddSnapshotParams) error {
	_, err := q.db.ExecContext(ctx, addSnapshot, arg.AggregateID, arg.Sequence, arg.State)
	return err
}

const addSubscriptionEventType = `-- name: AddSubscriptionEventType :exec
INSERT OR IGNORE INTO subscription_event_types (subscription_id, event_type_id)
VALUES (?1, ?2)
`

type AddSubscriptionEventTypeParams struct {
	SubscriptionID int64
	EventTypeID    int64
}

func (q *Queries) AddSubscriptionEventType(ctx context.Context, arg AddSubscriptionEventTypeParams) error {
	_, err := q.db.ExecContext(ctx, addSubscriptionEventType, arg.SubscriptionID, arg.EventTypeID)
	return err
}

const advanceSubscriptionCursor = `-- name: AdvanceSubscriptionCursor :exec
UPDATE subscriptions SET last_event_id = ?1, updated_at=CURRENT_TIMESTAMP WHERE id = ?2
`

type AdvanceSubscriptionCursorParams struct {
	LastEventID int64
	ID          int64
}

func (q *Queries) AdvanceSubscriptionCursor(ctx context.Context, arg AdvanceSubscriptionCursorParams) error {
	_, err := q.db.ExecContext(ctx, advanceSubscriptionCursor, arg.LastEventID, arg.ID)
	return err
}

const changeAggregateNaturalKey = `-- name: ChangeAggregateNaturalKey :exec
UPDATE aggregates SET natural_key=?1 WHERE id=?2
`

type ChangeAggregateNaturalKeyParams struct {
	NaturalKey  sql.NullString
	AggregateID int64
}

func (q *Queries) ChangeAggregateNaturalKey(ctx context.Context, arg ChangeAggregateNaturalKeyParams) error {
	_, err := q.db.ExecContext(ctx, changeAggregateNaturalKey, arg.NaturalKey, arg.AggregateID)
	return err
}

const claimSubscription = `-- name: ClaimSubscription :execrows
UPDATE subscriptions
SET lease_owner = ?1, lease_expires_at = ?2, updated_at=CURRENT_TIMESTAMP
WHERE name = ?3 AND active = 1 AND (lease_owner IS NULL OR lease_expires_at < ?4)
`

type ClaimSubscriptionParams struct {
	Owner          sql.NullString
	LeaseExpiresAt sql.NullTime
	Name           string
	Now            sql.NullTime
}

func (q *Queries) ClaimSubscription(ctx context.Context, arg ClaimSubscriptionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, claimSubscription,
		arg.Owner,
		arg.LeaseExpiresAt,
		arg.Name,
		arg.Now,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAggregateById = `-- name: GetAggregateById :one
SELECT id, natural_key FROM aggregates WHERE aggregate_type_id=?1 AND id=?2
`

type GetAggregateByIdParams struct {
	AggregateTypeID int64
	AggregateID     int64
}

type GetAggregateByIdRow struct {
	ID         int64
	NaturalKey sql.NullString
}

func (q *Queries) GetAggregateById(ctx context.Context, arg GetAggregateByIdParams) (GetAggregateByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getAggregateById, arg.AggregateTypeID, arg.AggregateID)
	var i GetAggregateByIdRow
	err := row.Scan(&i.ID, &i.NaturalKey)
	return i, err
}

const getAggregateIdByNaturalKey = `-- name: GetAggregateIdByNaturalKey :one
SELECT id FROM aggregates WHERE aggregate_type_id=?1 and natural_key=?2
`

type GetAggregateIdByNaturalKeyParams struct {
	AggregateTypeID int64
	NaturalKey      sql.NullString
}

func (q *Queries) GetAggregateIdByNaturalKey(ctx context.Context, arg GetAggregateIdByNaturalKeyParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAggregateIdByNaturalKey, arg.AggregateTypeID, arg.NaturalKey)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAggregateTypeIdByName = `-- name: GetAggregateTypeIdByName :one
SELECT id FROM aggregate_types WHERE name=?1
`

func (q *Queries) GetAggregateTypeIdByName(ctx context.Context, aggregateTypeName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getAggregateTypeIdByName, aggregateTypeName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getAggregateTypes = `-- name: GetAggregateTypes :many
SELECT id, name FROM aggregate_types
`

func (q *Queries) GetAggregateTypes(ctx context.Context) ([]AggregateType, error) {
	rows, err := q.db.QueryContext(ctx, getAggregateTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AggregateType
	for rows.Next() {
		var i AggregateType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventTypeIdByName = `-- name: GetEventTypeIdByName :one
SELECT id FROM event_types WHERE name=?1
`

func (q *Queries) GetEventTypeIdByName(ctx context.Context, eventName string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEventTypeIdByName, eventName)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getEventTypes = `-- name: GetEventTypes :many
SELECT id, name FROM event_types
`

func (q *Queries) GetEventTypes(ctx context.Context) ([]EventType, error) {
	rows, err := q.db.QueryContext(ctx, getEventTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventType
	for rows.Next() {
		var i EventType
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForAggregate = `-- name: GetEventsForAggregate :many
SELECT sequence, et.name event_type, state, event_time, reference
FROM events e
JOIN event_types AS et ON e.event_type_id = et.id
WHERE e.aggregate_id = ?1 AND sequence > ?2 
ORDER BY sequence
`

type GetEventsForAggregateParams struct {
	AggregateID   int64
	AfterSequence int64
}

type GetEventsForAggregateRow struct {
	Sequence  int64
	EventType string
	State     string
	EventTime time.Time
	Reference string
}

func (q *Queries) GetEventsForAggregate(ctx context.Context, arg GetEventsForAggregateParams) ([]GetEventsForAggregateRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventsForAggregate, arg.AggregateID, arg.AfterSequence)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventsForAggregateRow
	for rows.Next() {
		var i GetEventsForAggregateRow
		if err := rows.Scan(
			&i.Sequence,
			&i.EventType,
			&i.State,
			&i.EventTime,
			&i.Reference,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsForSubscription = `-- name: GetEventsForSubscription :many
SELECT id, aggregate_id, natural_key, sequence, aggregate_type_id, aggregate_type, event_type_id, event_type, event_time, state
FROM event_log
WHERE id > ?1
  AND (?2 IS NULL OR aggregate_type_id = ?2)
  AND (?3 IS NULL OR natural_key = ?3)
  AND (
    (?4 = 1 AND event_type_id IN (SELECT event_type_id FROM subscription_event_types WHERE subscription_id = ?5))
    OR
    (?4 = 0 AND (?6 IS NULL OR event_type_id = ?6))
  )
ORDER BY id ASC
LIMIT ?7
`

type GetEventsForSubscriptionParams struct {
	AfterID         int64
	AggregateTypeID interface{}
	AggregateKey    interface{}
	UseMulti        interface{}
	SubscriptionID  int64
	EventTypeID     interface{}
	Limit           int64
}

func (q *Queries) GetEventsForSubscription(ctx context.Context, arg GetEventsForSubscriptionParams) ([]EventLog, error) {
	rows, err := q.db.QueryContext(ctx, getEventsForSubscription,
		arg.AfterID,
		arg.AggregateTypeID,
		arg.AggregateKey,
		arg.UseMulti,
		arg.SubscriptionID,
		arg.EventTypeID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []EventLog
	for rows.Next() {
		var i EventLog
		if err := rows.Scan(
			&i.ID,
			&i.AggregateID,
			&i.NaturalKey,
			&i.Sequence,
			&i.AggregateTypeID,
			&i.AggregateType,
			&i.EventTypeID,
			&i.EventType,
			&i.EventTime,
			&i.State,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFirstEventIdFromTimestamp = `-- name: GetFirstEventIdFromTimestamp :one
SELECT id FROM events WHERE event_time >= ?1 ORDER BY id ASC LIMIT 1
`

func (q *Queries) GetFirstEventIdFromTimestamp(ctx context.Context, ts time.Time) (int64, error) {
	row := q.db.QueryRowContext(ctx, getFirstEventIdFromTimestamp, ts)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getMaxEventId = `-- name: GetMaxEventId :one
SELECT COALESCE(MAX(id), 0) AS id FROM events
`

func (q *Queries) GetMaxEventId(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxEventId)
	var id interface{}
	err := row.Scan(&id)
	return id, err
}

const getMostRecentSnapshot = `-- name: GetMostRecentSnapshot :one
SELECT aggregate_id, sequence, state
FROM snapshots
WHERE aggregate_id=?1 
ORDER BY sequence DESC
LIMIT 1
`

type GetMostRecentSnapshotRow struct {
	AggregateID int64
	Sequence    int64
	State       string
}

func (q *Queries) GetMostRecentSnapshot(ctx context.Context, aggregateID int64) (GetMostRecentSnapshotRow, error) {
	row := q.db.QueryRowContext(ctx, getMostRecentSnapshot, aggregateID)
	var i GetMostRecentSnapshotRow
	err := row.Scan(&i.AggregateID, &i.Sequence, &i.State)
	return i, err
}

const getSubscriptionByName = `-- name: GetSubscriptionByName :one
SELECT id, name, aggregate_type_id, event_type_id, aggregate_key,
       start_from, start_event_id, start_timestamp,
       last_event_id, active, lease_owner, lease_expires_at
FROM subscriptions WHERE name = ?1
`

type GetSubscriptionByNameRow struct {
	ID              int64
	Name            string
	AggregateTypeID sql.NullInt64
	EventTypeID     sql.NullInt64
	AggregateKey    sql.NullString
	StartFrom       string
	StartEventID    int64
	StartTimestamp  sql.NullTime
	LastEventID     int64
	Active          bool
	LeaseOwner      sql.NullString
	LeaseExpiresAt  sql.NullTime
}

func (q *Queries) GetSubscriptionByName(ctx context.Context, name string) (GetSubscriptionByNameRow, error) {
	row := q.db.QueryRowContext(ctx, getSubscriptionByName, name)
	var i GetSubscriptionByNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AggregateTypeID,
		&i.EventTypeID,
		&i.AggregateKey,
		&i.StartFrom,
		&i.StartEventID,
		&i.StartTimestamp,
		&i.LastEventID,
		&i.Active,
		&i.LeaseOwner,
		&i.LeaseExpiresAt,
	)
	return i, err
}

const releaseSubscription = `-- name: ReleaseSubscription :exec
UPDATE subscriptions SET lease_owner = NULL, lease_expires_at = NULL, updated_at=CURRENT_TIMESTAMP
WHERE name = ?1 AND lease_owner = ?2
`

type ReleaseSubscriptionParams struct {
	Name  string
	Owner sql.NullString
}

func (q *Queries) ReleaseSubscription(ctx context.Context, arg ReleaseSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, releaseSubscription, arg.Name, arg.Owner)
	return err
}

const renewSubscription = `-- name: RenewSubscription :execrows
UPDATE subscriptions
SET lease_expires_at = ?1, updated_at=CURRENT_TIMESTAMP
WHERE name = ?2 AND lease_owner = ?3 AND active = 1
`

type RenewSubscriptionParams struct {
	LeaseExpiresAt sql.NullTime
	Name           string
	Owner          sql.NullString
}

func (q *Queries) RenewSubscription(ctx context.Context, arg RenewSubscriptionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, renewSubscription, arg.LeaseExpiresAt, arg.Name, arg.Owner)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setSubscriptionActive = `-- name: SetSubscriptionActive :exec
UPDATE subscriptions SET active = ?1, updated_at=CURRENT_TIMESTAMP WHERE id = ?2
`

type SetSubscriptionActiveParams struct {
	Active bool
	ID     int64
}

func (q *Queries) SetSubscriptionActive(ctx context.Context, arg SetSubscriptionActiveParams) error {
	_, err := q.db.ExecContext(ctx, setSubscriptionActive, arg.Active, arg.ID)
	return err
}

const upsertSubscription = `-- name: UpsertSubscription :one

INSERT INTO subscriptions (
  name, aggregate_type_id, event_type_id, aggregate_key,
  start_from, start_event_id, start_timestamp
) VALUES (
  ?1, ?2, ?3, ?4,
  ?5, ?6, ?7
)
ON CONFLICT(name) DO UPDATE SET
  aggregate_type_id=excluded.aggregate_type_id,
  event_type_id=excluded.event_type_id,
  aggregate_key=excluded.aggregate_key,
  start_from=excluded.start_from,
  start_event_id=excluded.start_event_id,
  start_timestamp=excluded.start_timestamp,
  updated_at=CURRENT_TIMESTAMP
RETURNING id
`

type UpsertSubscriptionParams struct {
	Name            string
	AggregateTypeID sql.NullInt64
	EventTypeID     sql.NullInt64
	AggregateKey    sql.NullString
	StartFrom       string
	StartEventID    int64
	StartTimestamp  sql.NullTime
}

// Subscription Queries
func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, upsertSubscription,
		arg.Name,
		arg.AggregateTypeID,
		arg.EventTypeID,
		arg.AggregateKey,
		arg.StartFrom,
		arg.StartEventID,
		arg.StartTimestamp,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}
